// Generated by CoffeeScript 1.3.3
(function() {
  var $, Events, Model, Property, ServerSynchronisedCollection, Sync, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("./underscore-dep");

  $ = require('./jquery-dep');

  Events = require("./ViewFirstEvents");

  Sync = require("./ScrudSync");

  Property = require("./Property");

  ServerSynchronisedCollection = require("./ServerSynchronisedCollection");

  module.exports = Model = (function(_super) {
    var createClientId, lastClientIdUsed;

    __extends(Model, _super);

    Model.models = {};

    Model.find = function(modelType, id) {
      return this.models[modelType].instancesById[id];
    };

    lastClientIdUsed = 0;

    createClientId = function() {
      return lastClientIdUsed = lastClientIdUsed + 1;
    };

    function Model() {
      this.update = __bind(this.update, this);

      this["delete"] = __bind(this["delete"], this);

      this.save = __bind(this.save, this);

      var idProperty,
        _this = this;
      Model.__super__.constructor.apply(this, arguments);
      this.properties = {};
      this.clientId = createClientId();
      idProperty = this.createProperty("id", Number);
      idProperty.on("change", function(oldValue, newValue) {
        if (oldValue != null) {
          throw "Cannot set id as it has already been set";
        }
        if (_this.constructor.instancesById[newValue] != null) {
          throw "Cannot set the id to " + newValue + " as another object has that id";
        }
        return _this.constructor.instancesById[newValue] = _this;
      });
    }

    Model.prototype.createProperty = function(name, type, relationship) {
      var property,
        _this = this;
      property = new Property(name, type, relationship);
      property.on("change", function() {
        return _this.trigger("change");
      });
      this.properties[name] = property;
      return property;
    };

    Model.prototype.get = function(name) {
      return this.properties[name].get();
    };

    Model.prototype.getProperty = function(name) {
      return this.properties[name];
    };

    Model.prototype.set = function(name, value) {
      return this.properties[name].set(value);
    };

    Model.prototype.add = function(name, value) {
      return this.properties[name].add(value);
    };

    Model.prototype.removeAll = function(name) {
      return this.properties[name].removeAll();
    };

    Model.prototype.findProperty = function(key) {
      var current, element, elements, _i, _len;
      elements = key.split(".");
      current = this;
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        element = elements[_i];
        current = this.getProperty(element);
      }
      return current;
    };

    Model.prototype.onPropertyChange = function(propertyName, func) {
      return this.properties[propertyName].on("change", func);
    };

    Model.prototype.asJson = function(includeOnlyDirtyProperties) {
      var json, key, property, _ref;
      if (includeOnlyDirtyProperties == null) {
        includeOnlyDirtyProperties = true;
      }
      json = {};
      _ref = this.properties;
      for (key in _ref) {
        property = _ref[key];
        if (!includeOnlyDirtyProperties || property.isDirty || property.name === "id") {
          property.addToJson(json, includeOnlyDirtyProperties);
        }
      }
      return json;
    };

    Model.prototype.save = function() {
      var callbackFunctions, isPersisted, json, saveFunction;
      isPersisted = function() {
        return this.properties["id"].isSet();
      };
      callbackFunctions = {
        success: this.update
      };
      saveFunction = isPersisted() ? this.sync.update : this.sync.persist;
      json = JSON.stringify(this.asJson());
      return saveFunction(json, callbackFunctions);
    };

    Model.prototype["delete"] = function() {
      var callbackFunctions;
      callbackFunctions = {
        success: function() {
          return console.log("TODO will need to trigger an event");
        }
      };
      return this.sync["delete"](this.get("id"), callbackFunctions);
    };

    Model.prototype.update = function(json, clean) {
      var key, value, _results;
      if (clean == null) {
        clean = true;
      }
      _results = [];
      for (key in json) {
        value = json[key];
        _results.push(this.properties[key].setFromJson(value, clean = true));
      }
      return _results;
    };

    Model.extend = function(Child) {
      var ChildExtended, Surrogate, addCreateCollectionFunction, addInstances, addLoadMethod, ensureModelValid;
      ensureModelValid = function(Model) {
        if (!Model.type) {
          throw "type must be set as a static property: " + Model;
        }
      };
      addLoadMethod = function(Child) {
        return Child.load = function(json) {
          var childObject, id;
          id = json.id;
          childObject = Child.instancesById[id] != null ? Child.instancesById[id] : new Child;
          childObject.update(json);
          return childObject;
        };
      };
      addInstances = function(Child) {
        Child.instances = [];
        return Child.instancesById = {};
      };
      addCreateCollectionFunction = function(Child) {
        return Child.createCollection = function() {
          return new ServerSynchronisedCollection(Child);
        };
      };
      ensureModelValid(Child);
      ChildExtended = function() {
        Model.apply(this, arguments);
        Child.apply(this, arguments);
        this.constructor.instances.push(this);
        this.constructor.trigger("created", this);
        return this;
      };
      ChildExtended.modelName = Child.name;
      this.models[Child.name] = ChildExtended;
      Surrogate = function() {};
      Surrogate.prototype = this.prototype;
      ChildExtended.prototype = new Surrogate;
      ChildExtended.prototype.constructor = ChildExtended;
      _.extend(ChildExtended, new Events);
      _.extend(ChildExtended, Child);
      _.extend(ChildExtended.prototype, Child.prototype);
      addInstances(ChildExtended);
      addLoadMethod(ChildExtended);
      addCreateCollectionFunction(ChildExtended);
      return ChildExtended;
    };

    return Model;

  })(Events);

}).call(this);
