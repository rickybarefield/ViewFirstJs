// Generated by CoffeeScript 1.4.0
(function() {

  define([], function() {
    var BindHelpers;
    return BindHelpers = (function() {
      var uniqueNumber,
        _this = this;

      function BindHelpers() {}

      uniqueNumber = function() {
        if (BindHelpers.lastNumber != null) {
          BindHelpers.lastNumber++;
        } else {
          BindHelpers.lastNumber = 1;
        }
        return BindHelpers.lastNumber;
      };

      BindHelpers.prototype.bindCollection = function(collection, parentNode, func) {
        var $parent, addChild, boundModels, context, removeChild,
          _this = this;
        boundModels = {};
        addChild = function(modelToAdd) {
          var childNode;
          console.log("adding child");
          childNode = func(modelToAdd);
          if (childNode != null) {
            _this.bindNodes(childNode, modelToAdd);
            _this.bindNodeValues(childNode, modelToAdd);
            $parent.append(childNode);
            return boundModels[modelToAdd["cid"]] = childNode;
          }
        };
        removeChild = function(modelToRemove) {
          var childNode;
          childNode = boundModels[modelToRemove["cid"]];
          $(childNode).detach();
          return delete boundModels[modelToRemove["cid"]];
        };
        $parent = $(parentNode);
        context = uniqueNumber();
        console.log("context = " + context);
        collection.each(function(model) {
          return addChild(model);
        });
        collection.on("add", (function(newModel) {
          return addChild(newModel);
        }), context);
        collection.on("remove", (function(removedModel) {
          return removeChild(removedModel);
        }), context);
        return collection.on("reset", (function() {
          collection.off(null, null, context);
          return _this.bindCollection(collection, parentNode, func);
        }), context);
      };

      BindHelpers.prototype.bindNodeToResultOfFunction = function(node, func) {
        var affectingModel, affectingModels, previouslyBoundFunction, previouslyBoundModel, previouslyBoundModels, _i, _j, _len, _len1;
        previouslyBoundModels = node.get(0)["previouslyBoundModels"];
        previouslyBoundFunction = node.get(0)["previouslyBoundFunction"];
        affectingModels = func();
        if (previouslyBoundModels != null) {
          for (_i = 0, _len = previouslyBoundModels.length; _i < _len; _i++) {
            previouslyBoundModel = previouslyBoundModels[_i];
            previouslyBoundModel.off("change", currentlyBoundFunction);
          }
        }
        for (_j = 0, _len1 = affectingModels.length; _j < _len1; _j++) {
          affectingModel = affectingModels[_j];
          affectingModel.on("change", func);
        }
        node.get(0)["previouslyBoundModels"] = affectingModels;
        return node.get(0)["previouslyBoundFunction"] = func;
      };

      BindHelpers.prototype.bindNodes = function(node, model) {
        var _this = this;
        return BindHelpers.doForNodeAndChildren(node, function(node) {
          var doReplacement, getReplacementTextAndAffecingModels, originalText;
          getReplacementTextAndAffecingModels = function(nodeText, model) {
            var affectingModels, removeSurround, replacementText;
            removeSurround = function(str) {
              return str.match(/[^#{}]+/)[0];
            };
            affectingModels = [];
            replacementText = nodeText.replace(/#\{[^\}]*\}/g, function(match) {
              var currentModel, element, elements, key, _i, _len;
              key = removeSurround(match);
              elements = key.split(".");
              currentModel = model;
              for (_i = 0, _len = elements.length; _i < _len; _i++) {
                element = elements[_i];
                if ((currentModel != null)) {
                  affectingModels.push(currentModel);
                  currentModel = currentModel.get(element);
                }
              }
              if ((currentModel != null)) {
                return currentModel;
              } else {
                return "";
              }
            });
            return [replacementText, affectingModels];
          };
          originalText = node.get(0).nodeValue;
          doReplacement = function() {
            var affectingModels, replacementText, _ref;
            _ref = getReplacementTextAndAffecingModels(originalText, model), replacementText = _ref[0], affectingModels = _ref[1];
            node.get(0).nodeValue = replacementText;
            return affectingModels;
          };
          if ((node.get(0).nodeType === ViewFirst.TEXT_NODE || node.get(0).nodeType === ViewFirst.ATTR_NODE) && originalText.match(/#{.*}/)) {
            return _this.bindNodeToResultOfFunction(node, doReplacement);
          }
        });
      };

      BindHelpers.prototype.bindNodeValues = function(node, model, collections) {
        var addValidationAction, validations,
          _this = this;
        if (collections == null) {
          collections = {};
        }
        addValidationAction = function(property, action, reverseAction) {
          if (validations[property] == null) {
            validations[property] = [];
          }
          return validations[property].push([action, reverseAction]);
        };
        validations = {};
        model.on('invalid', function() {
          var action, actions, error, _i, _len, _ref, _results;
          console.log("error detected");
          _ref = model.validationError;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            error = _ref[_i];
            actions = validations[error.name];
            if (actions != null) {
              _results.push((function() {
                var _j, _len1, _results1;
                _results1 = [];
                for (_j = 0, _len1 = actions.length; _j < _len1; _j++) {
                  action = actions[_j];
                  _results1.push(action[0]());
                }
                return _results1;
              })());
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
        model.on('valid', function() {
          var action, actions, key, _results;
          console.log("Went valid");
          _results = [];
          for (key in validations) {
            actions = validations[key];
            _results.push((function() {
              var _i, _len, _results1;
              _results1 = [];
              for (_i = 0, _len = actions.length; _i < _len; _i++) {
                action = actions[_i];
                _results1.push(action[1]());
              }
              return _results1;
            })());
          }
          return _results;
        });
        return BindHelpers.doForNodeAndChildren(node, function(aNode) {
          var collection, collectionName, modelProperty, optionTemplate, property, validationClass;
          property = aNode.attr("data-property");
          if (property != null) {
            if (aNode.is("select")) {
              collectionName = aNode.attr("data-collection");
              collection = collections[collectionName];
              if (collection == null) {
                throw "Unable to find collection when binding node values of select element, failed to find " + property;
              }
              optionTemplate = aNode.children("option");
              optionTemplate.detach();
              modelProperty = model.get(property);
              _this.bindCollection(collection, aNode, function(modelInCollection) {
                var optionNode;
                optionNode = optionTemplate.clone();
                if (modelProperty === modelInCollection) {
                  optionNode.attr('selected', 'selected');
                }
                optionNode.get(0)["relatedModel"] = modelInCollection;
                aNode.change();
                return optionNode;
              });
              aNode.off("change.viewFirst");
              aNode.on("change.viewFirst", function() {
                var selectedOption;
                selectedOption = $(this).find("option:selected").get(0);
                if (selectedOption != null) {
                  return model.set(property, selectedOption["relatedModel"]);
                } else {
                  return model.set(property, null);
                }
              });
              return aNode.change();
            } else {
              _this.bindNodeToResultOfFunction(aNode, function() {
                aNode.val(model.get(property));
                return model;
              });
              validationClass = aNode.attr("data-invalid-class");
              if (validationClass != null) {
                addValidationAction(property, (function() {
                  return aNode.addClass(validationClass);
                }), (function() {
                  return aNode.removeClass(validationClass);
                }));
              }
              aNode.off("keypress.viewFirst");
              aNode.on("keypress.viewFirst", function(e) {
                if ((e.keyCode || e.which) === 13) {
                  model.set(property, aNode.val(), {
                    validate: true
                  });
                  if (!model.isNew()) {
                    return model.save();
                  }
                }
              });
              aNode.off("blur.viewFirst");
              aNode.on("blur.viewFirst", function() {
                model.set(property, aNode.val(), {
                  validate: true
                });
                if (!model.isNew()) {
                  return model.save();
                }
              });
              return aNode.val(model.get(property));
            }
          }
        });
      };

      BindHelpers.doForNodeAndChildren = function(node, func) {
        var attribute, attributes, childNode, _i, _j, _len, _len1, _ref, _results;
        func(node);
        attributes = node.get(0).attributes;
        if (attributes != null) {
          for (_i = 0, _len = attributes.length; _i < _len; _i++) {
            attribute = attributes[_i];
            func($(attribute));
          }
        }
        _ref = node.contents();
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          childNode = _ref[_j];
          _results.push(BindHelpers.doForNodeAndChildren($(childNode), func));
        }
        return _results;
      };

      return BindHelpers;

    }).call(this);
  });

}).call(this);
